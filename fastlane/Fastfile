# frozen_string_literal: true

fastlane_require 'digest'
fastlane_require 'zip'
fastlane_require 'aws-sdk-cloudfront'

UI.user_error!('Please run fastlane via `bundle exec`') unless FastlaneCore::Helper.bundler?

########################################################################
# Constants and Environment Variables
########################################################################
PROJECT_ROOT_FOLDER = File.dirname(File.expand_path(__dir__))
SECRETS_FOLDER = File.join(Dir.home, '.configure', 'studio', 'secrets')

APPLE_TEAM_ID = 'PZYM8XX95Q'
APPLE_BUNDLE_IDENTIFIER = 'com.automattic.studio'
APPLE_API_KEY_PATH = File.join(SECRETS_FOLDER, 'app_store_connect_fastlane_api_key.json')

# Use this instead of getting values from ENV directly
# It will throw an error if the requested value is missing
def get_required_env(key)
  UI.user_error!("Environment variable `#{key}` is not set.") unless ENV.key?(key)
  ENV.fetch(key)
end

before_all do |_lane|
  setup_ci # Fixes weird Keychain bugs
end

desc 'Download the development signing certificates to this machine'
lane :set_up_signing do |_options|
  sync_code_signing(
    platform: 'macos',
    app_identifier: APPLE_BUNDLE_IDENTIFIER,
    team_id: APPLE_TEAM_ID,
    type: 'developer_id',
    storage_mode: 's3',
    s3_bucket: 'a8c-fastlane-match',
    api_key_path: APPLE_API_KEY_PATH,
    readonly: true
  )

  puts lane_context[SharedValues::MATCH_PROVISIONING_PROFILE_MAPPING]
end

desc 'Notarize the compiled binary'
lane :notarize_binary do |_options|
  Dir[File.join(PROJECT_ROOT_FOLDER, 'out', '**', 'Studio.app')].each do |path|
    notarize(
      package: path,
      api_key_path: APPLE_API_KEY_PATH
    )
  end
end

desc 'Ship the binary to internal testers'
lane :distribute_dev_build do |_options|
  commit_metadata = last_git_commit
  commit_hash = commit_metadata[:commit_hash]

  binary_path_x64   = File.join(PROJECT_ROOT_FOLDER, 'out', 'Studio-darwin-x64', 'Studio.app.zip')
  binary_path_arm64 = File.join(PROJECT_ROOT_FOLDER, 'out', 'Studio-darwin-arm64', 'Studio.app.zip')
  binary_path_win32 = File.join(PROJECT_ROOT_FOLDER, 'out', 'make', 'squirrel.windows', 'x64', 'studio-setup.exe')

  manifest_path = File.join(PROJECT_ROOT_FOLDER, 'out', 'releases.json')
  build_number = get_required_env('BUILDKITE_BUILD_NUMBER')

  filename_root = 'studio'
  hashed_filename_x64   = "#{filename_root}-darwin-x64-#{commit_hash}.app.zip"
  hashed_filename_arm64 = "#{filename_root}-darwin-arm64-#{commit_hash}.app.zip"
  hashed_filename_win32 = "#{filename_root}-win32-#{commit_hash}.exe"

  latest_filename_x64   = "#{filename_root}-darwin-x64-latest.app.zip"
  latest_filename_arm64 = "#{filename_root}-darwin-arm64-latest.app.zip"
  latest_filename_win32 = "#{filename_root}-win32-latest.exe"

  bucket_folder = 'studio'

  upload_to_s3(
    bucket: 'a8c-apps-public-artifacts',
    key: "#{bucket_folder}/#{hashed_filename_x64}",
    file: binary_path_x64,
    if_exists: :fail,
    auto_prefix: false
  )

  upload_to_s3(
    bucket: 'a8c-apps-public-artifacts',
    key: "#{bucket_folder}/#{hashed_filename_arm64}",
    file: binary_path_arm64,
    if_exists: :fail,
    auto_prefix: false
  )

  upload_to_s3(
    bucket: 'a8c-apps-public-artifacts',
    key: "#{bucket_folder}/#{hashed_filename_win32}",
    file: binary_path_win32,
    if_exists: :fail,
    auto_prefix: false
  )

  upload_to_s3(
    bucket: 'a8c-apps-public-artifacts',
    key: "#{bucket_folder}/#{latest_filename_x64}",
    file: binary_path_x64,
    if_exists: :replace,
    auto_prefix: false
  )

  upload_to_s3(
    bucket: 'a8c-apps-public-artifacts',
    key: "#{bucket_folder}/#{latest_filename_arm64}",
    file: binary_path_arm64,
    if_exists: :replace,
    auto_prefix: false
  )

  upload_to_s3(
    bucket: 'a8c-apps-public-artifacts',
    key: "#{bucket_folder}/#{latest_filename_win32}",
    file: binary_path_win32,
    if_exists: :replace,
    auto_prefix: false
  )

  upload_to_s3(
    bucket: 'a8c-apps-public-artifacts',
    key: "#{bucket_folder}/releases.json",
    file: manifest_path,
    if_exists: :replace,
    auto_prefix: false
  )

  # Because we distribute via Cloudfront, we need to invalidate the `latest` build after
  # each upload, otherwise it'll be stale.
  clear_cloudfront_cache(
    paths: [
      "/#{bucket_folder}/#{latest_filename_x64}",
      "/#{bucket_folder}/#{latest_filename_arm64}",
      "/#{bucket_folder}/#{latest_filename_win32}",
      "/#{bucket_folder}/releases.json"
    ],
    commit_hash: "#{commit_hash}-#{build_number}"
  )

  # Copy the file into position to be picked up by the Buildkite agent and saved with the job
  FileUtils.cp(binary_path_x64, File.join(PROJECT_ROOT_FOLDER, 'out', hashed_filename_x64))
  FileUtils.cp(binary_path_arm64, File.join(PROJECT_ROOT_FOLDER, 'out', hashed_filename_arm64))

  download_url_x64     = "https://cdn.a8c-ci.services/#{bucket_folder}/#{hashed_filename_x64}"
  download_url_arm64   = "https://cdn.a8c-ci.services/#{bucket_folder}/#{hashed_filename_arm64}"
  download_url_windows = "https://cdn.a8c-ci.services/#{bucket_folder}/#{hashed_filename_win32}"

  buildkite_annotate(
    context: 'cdn-link',
    style: 'info',
    message: "ðŸ”— Build available for download for Macs with [Intel](#{download_url_x64}) and [Apple Silicon](#{download_url_arm64}), and for [Windows](#{download_url_windows})"
  )
end

desc 'Ship release build'
lane :distribute_release_build do |_options|
  commit_metadata = last_git_commit
  commit_hash = commit_metadata[:commit_hash]

  binary_path_x64   = File.join(PROJECT_ROOT_FOLDER, 'out', 'Studio-darwin-x64', 'Studio.app.zip')
  binary_path_arm64 = File.join(PROJECT_ROOT_FOLDER, 'out', 'Studio-darwin-arm64', 'Studio.app.zip')
  manifest_path     = File.join(PROJECT_ROOT_FOLDER, 'out', 'releases.json')
  release_tag       = get_required_env('BUILDKITE_TAG')
  build_number      = get_required_env('BUILDKITE_BUILD_NUMBER')

  filename_root         = 'studio-darwin'
  tagged_filename_x64   = "#{filename_root}-x64-#{release_tag}.app.zip"
  tagged_filename_arm64 = "#{filename_root}-arm64-#{release_tag}.app.zip"

  bucket_folder = 'studio'

  upload_to_s3(
    bucket: 'a8c-apps-public-artifacts',
    key: "#{bucket_folder}/#{tagged_filename_x64}",
    file: binary_path_x64,
    if_exists: :fail,
    auto_prefix: false
  )

  upload_to_s3(
    bucket: 'a8c-apps-public-artifacts',
    key: "#{bucket_folder}/#{tagged_filename_arm64}",
    file: binary_path_arm64,
    if_exists: :fail,
    auto_prefix: false
  )

  upload_to_s3(
    bucket: 'a8c-apps-public-artifacts',
    key: "#{bucket_folder}/releases.json",
    file: manifest_path,
    if_exists: :replace,
    auto_prefix: false
  )

  # Because we distribute via Cloudfront, we need to invalidate the manifest file after
  # each upload, otherwise it'll be stale.
  clear_cloudfront_cache(
    paths: [
      "/#{bucket_folder}/releases.json"
    ],
    commit_hash: "#{commit_hash}-#{build_number}"
  )

  # Copy the file into position to be picked up by the Buildkite agent and saved with the job
  FileUtils.cp(binary_path_x64, File.join(PROJECT_ROOT_FOLDER, 'out', tagged_filename_x64))
  FileUtils.cp(binary_path_arm64, File.join(PROJECT_ROOT_FOLDER, 'out', tagged_filename_arm64))

  download_url_x64 = "https://cdn.a8c-ci.services/#{bucket_folder}/#{tagged_filename_x64}"
  download_url_arm64 = "https://cdn.a8c-ci.services/#{bucket_folder}/#{tagged_filename_arm64}"

  slack(
    username: 'CI Bot',
    icon_url: 'https://octodex.github.com/images/jenktocat.jpg',
    message: ":tada: #{release_tag} is now available! :tada:",
    channel: '#dotcom-studio',
    success: true,
    slack_url: get_required_env('SLACK_WEBHOOK'),
    payload: {
      ':apple_logo: Release for macOS': "Available for [Intel](#{download_url_x64}) and [Apple Silicon](#{download_url_arm64})"
    },
    default_payloads: []
  )

  buildkite_annotate(
    context: 'cdn-link',
    style: 'info',
    message: "ðŸ”— Build available for download for [Intel](#{download_url_x64}) and [Apple Silicon](#{download_url_arm64})"
  )
end

def clear_cloudfront_cache(paths:, commit_hash:)
  Aws::CloudFront::Client.new.create_invalidation(
    distribution_id: 'EF4A01YASGPY5',
    invalidation_batch: {
      paths: {
        quantity: paths.length,
        items: paths
      },
      caller_reference: commit_hash
    }
  )
end
