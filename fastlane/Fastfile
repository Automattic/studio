# frozen_string_literal: true

fastlane_require 'digest'
fastlane_require 'zip'
fastlane_require 'aws-sdk-cloudfront'

UI.user_error!('Please run fastlane via `bundle exec`') unless FastlaneCore::Helper.bundler?

########################################################################
# Constants and Environment Variables
########################################################################
PROJECT_ROOT_FOLDER = File.dirname(File.expand_path(__dir__))
SECRETS_FOLDER = File.join(Dir.home, '.configure', 'studio', 'secrets')

APPLE_TEAM_ID = 'PZYM8XX95Q'
APPLE_BUNDLE_IDENTIFIER = 'com.automattic.studio'
APPLE_API_KEY_PATH = File.join(SECRETS_FOLDER, 'app_store_connect_fastlane_api_key.json')

# Use this instead of getting values from ENV directly
# It will throw an error if the requested value is missing
def get_required_env(key)
  UI.user_error!("Environment variable `#{key}` is not set.") unless ENV.key?(key)
  ENV.fetch(key)
end

before_all do |_lane|
  setup_ci # Fixes weird Keychain bugs
end

desc 'Download the development signing certificates to this machine'
lane :set_up_signing do |_options|
  sync_code_signing(
    platform: 'macos',
    app_identifier: APPLE_BUNDLE_IDENTIFIER,
    team_id: APPLE_TEAM_ID,
    type: 'developer_id',

    storage_mode: 'google_cloud',
    google_cloud_bucket_name: 'a8c-fastlane-match',
    google_cloud_keys_file: File.join(SECRETS_FOLDER, 'google_cloud_keys.json'),
    api_key_path: APPLE_API_KEY_PATH,

    readonly: true
  )

  puts lane_context[SharedValues::MATCH_PROVISIONING_PROFILE_MAPPING]
end

desc 'Notarize the compiled binary'
lane :notarize_binary do |_options|
  notarize(
    package: File.join(PROJECT_ROOT_FOLDER, 'out', 'Studio-darwin-universal', 'Studio.app'),
    api_key_path: APPLE_API_KEY_PATH
  )
end

desc 'Ship the binary to internal testers'
lane :distribute_dev_build do |_options|
  commit_metadata = last_git_commit
  commit_hash = commit_metadata[:commit_hash]
  commit_message = commit_metadata[:message]

  binary_path = File.join(PROJECT_ROOT_FOLDER, 'out', 'Studio-darwin-universal', 'Studio.app.zip')
  manifest_path = File.join(PROJECT_ROOT_FOLDER, 'out', 'releases.json')
  build_number = get_required_env('BUILDKITE_BUILD_NUMBER')

  filename_root = 'studio-darwin-universal'
  hashed_filename = "#{filename_root}-#{commit_hash}.app.zip"
  latest_filename = "#{filename_root}-latest.app.zip"

  bucket_folder = 'studio'

  upload_to_s3(
    bucket: 'a8c-apps-public-artifacts',
    key: "#{bucket_folder}/#{hashed_filename}",
    file: binary_path,
    if_exists: :fail,
    auto_prefix: false
  )

  upload_to_s3(
    bucket: 'a8c-apps-public-artifacts',
    key: "#{bucket_folder}/#{latest_filename}",
    file: binary_path,
    if_exists: :replace,
    auto_prefix: false
  )

  upload_to_s3(
    bucket: 'a8c-apps-public-artifacts',
    key: "#{bucket_folder}/releases.json",
    file: manifest_path,
    if_exists: :replace,
    auto_prefix: false
  )

  # Because we distribute via Cloudfront, we need to invalidate the `latest` build after
  # each upload, otherwise it'll be stale.
  clear_cloudfront_cache(
    paths: [
      "/#{bucket_folder}/#{latest_filename}",
      "/#{bucket_folder}/releases.json"
    ],
    commit_hash: "#{commit_hash}-#{build_number}"
  )

  # Copy the file into position to be picked up by the Buildkite agent and saved with the job
  FileUtils.cp(binary_path, File.join(PROJECT_ROOT_FOLDER, 'out', hashed_filename))

  download_url = "https://cdn.a8c-ci.services/#{bucket_folder}/#{hashed_filename}"
  commit_link = "<https://github.com/Automattic/local-environment/commit/#{commit_hash}|#{commit_hash[0...7]}>"
  commit_message_short = commit_message[/.*/].gsub(/#(\d+)\b/, '<https://github.com/Automattic/local-environment/pull/\1|#\1>')

  slack(
    username: 'CI Bot',
    icon_url: 'https://octodex.github.com/images/jenktocat.jpg',
    message: ":apple_logo: macOS build for commit #{commit_link} is now [available here](#{download_url})",
    channel: '#dotcom-hosting-local-playground',
    success: true,
    slack_url: get_required_env('SLACK_WEBHOOK'),
    payload: { 'Commit Message': commit_message_short },
    default_payloads: []
  )

  buildkite_annotate(
    context: 'cdn-link',
    style: 'info',
    message: "ðŸ”— Build availble for download at [#{download_url}](#{download_url})"
  )
end

desc 'Ship release build'
lane :distribute_release_build do |_options|
  commit_metadata = last_git_commit
  commit_hash = commit_metadata[:commit_hash]

  binary_path = File.join(PROJECT_ROOT_FOLDER, 'out', 'Studio-darwin-universal', 'Studio.app.zip')
  manifest_path = File.join(PROJECT_ROOT_FOLDER, 'out', 'releases.json')
  release_tag = get_required_env('BUILDKITE_TAG')
  build_number = get_required_env('BUILDKITE_BUILD_NUMBER')

  filename_root = 'studio-darwin-universal'
  tagged_filename = "#{filename_root}-#{release_tag}.app.zip"

  bucket_folder = 'studio'

  upload_to_s3(
    bucket: 'a8c-apps-public-artifacts',
    key: "#{bucket_folder}/#{tagged_filename}",
    file: binary_path,
    if_exists: :fail,
    auto_prefix: false
  )

  upload_to_s3(
    bucket: 'a8c-apps-public-artifacts',
    key: "#{bucket_folder}/releases.json",
    file: manifest_path,
    if_exists: :replace,
    auto_prefix: false
  )

  # Because we distribute via Cloudfront, we need to invalidate the manifest file after
  # each upload, otherwise it'll be stale.
  clear_cloudfront_cache(
    paths: [
      "/#{bucket_folder}/releases.json"
    ],
    commit_hash: "#{commit_hash}-#{build_number}"
  )

  # Copy the file into position to be picked up by the Buildkite agent and saved with the job
  FileUtils.cp(binary_path, File.join(PROJECT_ROOT_FOLDER, 'out', tagged_filename))

  download_url = "https://cdn.a8c-ci.services/#{bucket_folder}/#{tagged_filename}"

  buildkite_annotate(
    context: 'cdn-link',
    style: 'info',
    message: "ðŸ”— Build availble for download at [#{download_url}](#{download_url})"
  )
end

def clear_cloudfront_cache(paths:, commit_hash:)
  Aws::CloudFront::Client.new.create_invalidation(
    distribution_id: 'EF4A01YASGPY5',
    invalidation_batch: {
      paths: {
        quantity: paths.length,
        items: paths
      },
      caller_reference: commit_hash
    }
  )
end
