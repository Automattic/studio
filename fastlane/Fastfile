# frozen_string_literal: true

fastlane_require 'digest'
fastlane_require 'zip'
fastlane_require 'aws-sdk-cloudfront'

UI.user_error!('Please run fastlane via `bundle exec`') unless FastlaneCore::Helper.bundler?

########################################################################
# Constants and Environment Variables
########################################################################
PROJECT_ROOT_FOLDER = File.dirname(File.expand_path(__dir__))
SECRETS_FOLDER = File.join(Dir.home, '.configure', 'studio', 'secrets')
BUILDS_FOLDER = File.join(PROJECT_ROOT_FOLDER, 'out')

APPLE_TEAM_ID = 'PZYM8XX95Q'
APPLE_BUNDLE_IDENTIFIER = 'com.automattic.studio'
APPLE_API_KEY_PATH = File.join(SECRETS_FOLDER, 'app_store_connect_fastlane_api_key.json')

CDN_URL = 'https://cdn.a8c-ci.services'

# Use this instead of getting values from ENV directly
# It will throw an error if the requested value is missing
def get_required_env(key)
  UI.user_error!("Environment variable `#{key}` is not set.") unless ENV.key?(key)
  ENV.fetch(key)
end

before_all do |_lane|
  setup_ci # Fixes weird Keychain bugs
end

desc 'Download the development signing certificates to this machine'
lane :set_up_signing do |_options|
  sync_code_signing(
    platform: 'macos',
    app_identifier: APPLE_BUNDLE_IDENTIFIER,
    team_id: APPLE_TEAM_ID,
    type: 'developer_id',
    storage_mode: 's3',
    s3_bucket: 'a8c-fastlane-match',
    api_key_path: APPLE_API_KEY_PATH,
    readonly: true
  )
end

desc 'Notarize the compiled binary'
lane :notarize_binary do |_options|
  Dir[File.join(BUILDS_FOLDER, '**', 'Studio.app')].each do |path|
    notarize(
      package: path,
      api_key_path: APPLE_API_KEY_PATH
    )
  end
end

desc 'Ship the binary to internal testers'
lane :distribute_dev_build do |_options|
  commit_metadata = last_git_commit
  commit_hash = commit_metadata[:commit_hash]
  build_number = get_required_env('BUILDKITE_BUILD_NUMBER')

  distribute_builds(commit_hash:, build_number:)
end

desc 'Ship release build'
lane :distribute_release_build do |_options|
  commit_metadata = last_git_commit
  commit_hash = commit_metadata[:commit_hash]
  release_tag = get_required_env('BUILDKITE_TAG')
  build_number = get_required_env('BUILDKITE_BUILD_NUMBER')

  urls = distribute_builds(
    commit_hash:,
    build_number:,
    release_tag:
  )

  slack(
    username: 'CI Bot',
    icon_url: 'https://octodex.github.com/images/jenktocat.jpg',
    message: ":tada: #{release_tag} is now available! :tada:",
    channel: '#dotcom-studio',
    success: true,
    slack_url: get_required_env('SLACK_WEBHOOK'),
    payload: {
      ':studio-app-icon-mac: Release available for': "Available for Mac in [Intel](#{urls[:x64]}), [Apple Silicon](#{urls[:arm64]}) and [Universal](#{urls[:mac_universal]}) architectures, and for [Windows](#{urls[:windows]})."
    },
    default_payloads: []
  )
end

def distribute_builds(commit_hash:, build_number:, release_tag: nil)
  # If we are distributing a build without a tag, i.e. a development build, we also want to update the latest build reference for distribution.
  update_latest = release_tag.nil?
  suffix = release_tag.nil? ? commit_hash : release_tag

  binary_path_mac = File.join(BUILDS_FOLDER, 'Studio-darwin-universal', 'Studio.app.zip')
  binary_path_x64 = File.join(BUILDS_FOLDER, 'Studio-darwin-x64', 'Studio.app.zip')
  binary_path_arm64 = File.join(BUILDS_FOLDER, 'Studio-darwin-arm64', 'Studio.app.zip')
  binary_path_win32 = File.join(BUILDS_FOLDER, 'make', 'squirrel.windows', 'x64', 'studio-setup.exe')

  manifest_path = File.join(BUILDS_FOLDER, 'releases.json')

  filename_root = 'studio'
  filename_mac = "#{filename_root}-darwin-universal-#{commit_hash}.app.zip"
  filename_x64   = "#{filename_root}-darwin-x64-#{suffix}.app.zip"
  filename_arm64 = "#{filename_root}-darwin-arm64-#{suffix}.app.zip"
  filename_win32 = "#{filename_root}-win32-#{suffix}.exe"

  bucket_name = 'a8c-apps-public-artifacts'
  bucket_folder = 'studio'

  upload_to_s3(
    bucket: bucket_name,
    key: "#{bucket_folder}/#{filename_mac}",
    file: binary_path_mac,
    if_exists: :fail,
    auto_prefix: false
  )

  upload_to_s3(
    bucket: bucket_name,
    key: "#{bucket_folder}/#{filename_x64}",
    file: binary_path_x64,
    if_exists: :fail,
    auto_prefix: false
  )

  upload_to_s3(
    bucket: bucket_name,
    key: "#{bucket_folder}/#{filename_arm64}",
    file: binary_path_arm64,
    if_exists: :fail,
    auto_prefix: false
  )

  upload_to_s3(
    bucket: bucket_name,
    key: "#{bucket_folder}/#{filename_win32}",
    file: binary_path_win32,
    if_exists: :fail,
    auto_prefix: false
  )

  upload_to_s3(
    bucket: bucket_name,
    key: "#{bucket_folder}/releases.json",
    file: manifest_path,
    if_exists: :replace,
    auto_prefix: false
  )

  cache_paths_to_clear = [
    "/#{bucket_folder}/releases.json"
  ]

  if update_latest
    latest_filename_mac = "#{filename_root}-darwin-universal-latest.app.zip"
    latest_filename_x64 = "#{filename_root}-darwin-x64-latest.app.zip"
    latest_filename_arm64 = "#{filename_root}-darwin-arm64-latest.app.zip"
    latest_filename_win32 = "#{filename_root}-win32-latest.exe"

    upload_to_s3(
      bucket: bucket_name,
      key: "#{bucket_folder}/#{latest_filename_mac}",
      file: binary_path_mac,
      if_exists: :replace,
      auto_prefix: false
    )

    upload_to_s3(
      bucket: bucket_name,
      key: "#{bucket_folder}/#{latest_filename_x64}",
      file: binary_path_x64,
      if_exists: :replace,
      auto_prefix: false
    )

    upload_to_s3(
      bucket: bucket_name,
      key: "#{bucket_folder}/#{latest_filename_arm64}",
      file: binary_path_arm64,
      if_exists: :replace,
      auto_prefix: false
    )

    upload_to_s3(
      bucket: bucket_name,
      key: "#{bucket_folder}/#{latest_filename_win32}",
      file: binary_path_win32,
      if_exists: :replace,
      auto_prefix: false
    )

    cache_paths_to_clear += [
      "/#{bucket_folder}/#{latest_filename_mac}",
      "/#{bucket_folder}/#{latest_filename_x64}",
      "/#{bucket_folder}/#{latest_filename_arm64}",
      "/#{bucket_folder}/#{latest_filename_win32}"
    ]
  end

  # Because we distribute via Cloudfront, we need to invalidate the manifest
  # and the latest build (if building for release) after each upload, otherwise
  # it'll be stale.
  clear_cloudfront_cache(
    paths: cache_paths_to_clear,
    commit_hash: "#{commit_hash}-#{build_number}"
  )

  # Copy the file into position to be picked up by the Buildkite agent and saved with the job
  FileUtils.cp(binary_path_mac, File.join(BUILDS_FOLDER, filename_mac))
  FileUtils.cp(binary_path_x64, File.join(BUILDS_FOLDER, filename_x64))
  FileUtils.cp(binary_path_arm64, File.join(BUILDS_FOLDER, filename_arm64))
  FileUtils.cp(binary_path_win32, File.join(BUILDS_FOLDER, filename_win32))

  download_url_mac = "#{CDN_URL}/#{bucket_folder}/#{filename_mac}"
  download_url_x64 = "#{CDN_URL}/#{bucket_folder}/#{filename_x64}"
  download_url_arm64 = "#{CDN_URL}/#{bucket_folder}/#{filename_arm64}"
  download_url_windows = "#{CDN_URL}/#{bucket_folder}/#{filename_win32}"

  buildkite_annotate(
    context: 'cdn-link',
    style: 'info',
    message: "ðŸ”— Build available for Mac in [Intel](#{download_url_x64}), [Apple Silicon](#{download_url_arm64}), and [Universal](#{download_url_mac}) architectures, and for [Windows](#{download_url_win32})."
  )

  # Return the download URLs so callers can use them for further processing or messaging.
  {
    mac_universal: download_url_mac,
    x64: download_url_x64,
    arm64: download_url_arm64,
    windows: download_url_windows
  }
end

def clear_cloudfront_cache(paths:, commit_hash:)
  Aws::CloudFront::Client.new.create_invalidation(
    distribution_id: 'EF4A01YASGPY5',
    invalidation_batch: {
      paths: {
        quantity: paths.length,
        items: paths
      },
      caller_reference: commit_hash
    }
  )
end
