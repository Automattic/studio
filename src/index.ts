import { app, BrowserWindow, ipcMain, session, type IpcMainInvokeEvent } from 'electron';
import * as ipcHandlers from './ipc-handlers';
import { stopAllServersOnQuit } from './site-server';
import packageJson from '../package.json';
import { setupLogging } from './logging';
import { loadUserData, saveUserData } from './storage/user-data';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if ( require( 'electron-squirrel-startup' ) ) {
	app.quit();
}

app.setName( packageJson.productName );

setupLogging();

// Forces all renderers to be sandboxed. IPC is the only way render processes will
// be able to perform privileged operations.
app.enableSandbox();

// Prevent navigation to anywhere other than known locations
app.on( 'web-contents-created', ( event, contents ) => {
	contents.on( 'will-navigate', ( event, navigationUrl ) => {
		const { origin } = new URL( navigationUrl );
		if ( origin !== new URL( MAIN_WINDOW_WEBPACK_ENTRY ).origin ) {
			event.preventDefault();
		}
	} );
	contents.setWindowOpenHandler( ( { url } ) => {
		return { action: 'deny' };
	} );
} );

function createWindow() {
	const mainWindow = new BrowserWindow( {
		height: 800,
		width: 1200,
		webPreferences: {
			preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
		},
	} );

	mainWindow.loadURL( MAIN_WINDOW_WEBPACK_ENTRY );

	// Open the DevTools if the user had it open last time they used the app.
	// During development the dev tools default to open.
	loadUserData().then( ( { devToolsOpen } ) => {
		if (
			devToolsOpen ||
			( process.env.NODE_ENV === 'development' && devToolsOpen === undefined )
		) {
			mainWindow.webContents.openDevTools();
		}
	} );

	mainWindow.webContents.on( 'devtools-opened', async () => {
		const data = await loadUserData();
		data.devToolsOpen = true;
		await saveUserData( data );
	} );

	mainWindow.webContents.on( 'devtools-closed', async () => {
		const data = await loadUserData();
		data.devToolsOpen = false;
		await saveUserData( data );
	} );
}

function validateIpcSender( event: IpcMainInvokeEvent ) {
	if ( new URL( event.senderFrame.url ).origin === new URL( MAIN_WINDOW_WEBPACK_ENTRY ).origin ) {
		return true;
	}

	throw new Error( 'Failed IPC sender validation check: ' + event.senderFrame.url );
}

function setupIpc() {
	for ( const [ key, handler ] of Object.entries( ipcHandlers ) ) {
		if ( typeof handler === 'function' && key !== 'logRendererMessage' ) {
			ipcMain.handle( key, function ( event, ...args ) {
				try {
					validateIpcSender( event );

					// Invoke the handler. Param types have already been type checked by code
					// in ipc-types.d.ts, so we can ignore the handler function's param types here.
					return ( handler as any )( event, ...args );
				} catch ( error ) {
					console.error( error );
					throw error;
				}
			} );
		}

		// logRendererMessage is handled specially because it uses the (hopefully more efficient)
		// fire-and-forget .send method instead of .invoke
		if ( typeof handler === 'function' && key === 'logRendererMessage' ) {
			ipcMain.on( key, function ( event, level, ...args ) {
				try {
					validateIpcSender( event );
					handler( event, level, ...args );
				} catch ( error ) {
					console.error( error );
					throw error;
				}
			} );
		}
	}
}

app.on( 'ready', () => {
	console.log( `App version: ${ app.getVersion() }` );
	console.log( `Local timezone: ${ Intl.DateTimeFormat().resolvedOptions().timeZone }` );
	console.log( `App locale: ${ app.getLocale() }` );
	console.log( `System locale: ${ app.getSystemLocale() }` );

	// By default Electron automatically approves all permissions requests (e.g. notifications, webcam)
	// We'll opt-in to permissions we specifically need instead.
	session.defaultSession.setPermissionRequestHandler( ( webContents, permission, callback ) => {
		// Reject all permission requests
		callback( false );
	} );

	session.defaultSession.webRequest.onHeadersReceived( ( details, callback ) => {
		const policies = [
			"default-src 'self'",
			"script-src-attr 'none'",
			"style-src 'self' 'unsafe-inline'", // unsafe-inline is used by tailwind
			process.env.NODE_ENV === 'development' && "script-src 'self' 'unsafe-eval'", // unsafe-eval is used by hot reloading
		];

		callback( {
			responseHeaders: {
				...details.responseHeaders,
				'Content-Security-Policy': [ policies.filter( Boolean ).join( '; ' ) ],
			},
		} );
	} );

	setupIpc();
	createWindow();
} );

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on( 'window-all-closed', () => {
	if ( process.platform !== 'darwin' ) {
		app.quit();
	}
} );

app.on( 'quit', () => {
	stopAllServersOnQuit();
} );

app.on( 'activate', () => {
	// On OS X it's common to re-create a window in the app when the
	// dock icon is clicked and there are no other windows open.
	if ( BrowserWindow.getAllWindows().length === 0 ) {
		createWindow();
	}
} );
