import { app, BrowserWindow, ipcMain, session, type IpcMainInvokeEvent, protocol, Menu, MenuItem } from 'electron';
import * as ipcHandlers from './ipc-handlers';
import { stopAllServersOnQuit } from './site-server';
import packageJson from '../package.json';
import { setupLogging } from './logging';
import { loadUserData, saveUserData } from './storage/user-data';
import path from 'path';
import { PROTOCOL_PREFIX, handleAuthCallback } from './lib/oauth';
import * as Sentry from '@sentry/electron/main';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

Sentry.init( {
	dsn: 'https://97693275b2716fb95048c6d12f4318cf@o248881.ingest.sentry.io/4506612776501248',
	debug: true,
	enabled: process.env.NODE_ENV !== 'development',
} );

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if ( require( 'electron-squirrel-startup' ) ) {
	app.quit();
}

app.setName( packageJson.productName );

let mainWindow: BrowserWindow | null = null;

if ( process.defaultApp ) {
	if ( process.argv.length >= 2 ) {
		app.setAsDefaultProtocolClient( PROTOCOL_PREFIX, process.execPath, [
			path.resolve( process.argv[ 1 ] ),
		] );
	}
} else {
	app.setAsDefaultProtocolClient( PROTOCOL_PREFIX );
}

const gotTheLock = app.requestSingleInstanceLock();

if ( ! gotTheLock ) {
	app.quit();
} else {
	app.on( 'second-instance', ( _event, _commandLine, _workingDirectory ) => {
		// Someone tried to run a second instance, we should focus our window.
		if ( mainWindow ) {
			if ( mainWindow.isMinimized() ) mainWindow.restore();
			mainWindow.focus();
		}
	} );
}

setupLogging();

// Forces all renderers to be sandboxed. IPC is the only way render processes will
// be able to perform privileged operations.
app.enableSandbox();

// Prevent navigation to anywhere other than known locations
app.on( 'web-contents-created', ( _event, contents ) => {
	contents.on( 'will-navigate', ( event, navigationUrl ) => {
		const { origin } = new URL( navigationUrl );
		const allowedOrigins = [
			new URL( MAIN_WINDOW_WEBPACK_ENTRY ).origin,
			`${ PROTOCOL_PREFIX }://auth`,
			'https://wordpress.com',
			'https://public-api.wordpress.com',
		];
		if ( ! allowedOrigins.includes( origin ) ) {
			event.preventDefault();
		}
	} );
	contents.setWindowOpenHandler( ( { url } ) => {
		return { action: 'deny' };
	} );
} );

function createWindow(): BrowserWindow {
	const mainWindow = new BrowserWindow( {
		height: 800,
		width: 1200,
		webPreferences: {
			preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
		},
	} );

	mainWindow.loadURL( MAIN_WINDOW_WEBPACK_ENTRY );

	// Open the DevTools if the user had it open last time they used the app.
	// During development the dev tools default to open.
	loadUserData().then( ( { devToolsOpen } ) => {
		if (
			devToolsOpen ||
			( process.env.NODE_ENV === 'development' && devToolsOpen === undefined )
		) {
			mainWindow?.webContents.openDevTools();
		}
	} );

	mainWindow.webContents.on( 'devtools-opened', async () => {
		const data = await loadUserData();
		data.devToolsOpen = true;
		await saveUserData( data );
	} );

	mainWindow.webContents.on( 'devtools-closed', async () => {
		const data = await loadUserData();
		data.devToolsOpen = false;
		await saveUserData( data );
	} );

	return mainWindow;
}

function validateIpcSender( event: IpcMainInvokeEvent ) {
	if ( new URL( event.senderFrame.url ).origin === new URL( MAIN_WINDOW_WEBPACK_ENTRY ).origin ) {
		return true;
	}

	throw new Error( 'Failed IPC sender validation check: ' + event.senderFrame.url );
}

function setupIpc() {
	for ( const [ key, handler ] of Object.entries( ipcHandlers ) ) {
		if ( typeof handler === 'function' && key !== 'logRendererMessage' ) {
			ipcMain.handle( key, function ( event, ...args ) {
				try {
					validateIpcSender( event );

					// Invoke the handler. Param types have already been type checked by code
					// in ipc-types.d.ts, so we can ignore the handler function's param types here.
					return ( handler as any )( event, ...args );
				} catch ( error ) {
					console.error( error );
					throw error;
				}
			} );
		}

		// logRendererMessage is handled specially because it uses the (hopefully more efficient)
		// fire-and-forget .send method instead of .invoke
		if ( typeof handler === 'function' && key === 'logRendererMessage' ) {
			ipcMain.on( key, function ( event, level, ...args ) {
				try {
					validateIpcSender( event );
					handler( event, level, ...args );
				} catch ( error ) {
					console.error( error );
					throw error;
				}
			} );
		}
	}
}

protocol.registerSchemesAsPrivileged( [
	{
		scheme: PROTOCOL_PREFIX,
		privileges: {
			standard: true,
			secure: true,
			supportFetchAPI: true,
		},
	},
] );

function setupCustomProtocolHandler() {
	protocol.handle( PROTOCOL_PREFIX, ( request ): Response => {
		const { host, hash } = new URL( request.url );
		if ( host === 'auth' ) {
			const authResult = handleAuthCallback( hash );
			if ( authResult instanceof Error ) {
				ipcMain.emit( 'auth-callback', null, { error: authResult } );
			} else {
				ipcMain.emit( 'auth-callback', null, { token: authResult } );
			}
		}
		return new Response();
	} );
}

app.on( 'ready', () => {
	console.log( `App version: ${ app.getVersion() }` );
	console.log( `Local timezone: ${ Intl.DateTimeFormat().resolvedOptions().timeZone }` );
	console.log( `App locale: ${ app.getLocale() }` );
	console.log( `System locale: ${ app.getSystemLocale() }` );

	// By default Electron automatically approves all permissions requests (e.g. notifications, webcam)
	// We'll opt-in to permissions we specifically need instead.
	session.defaultSession.setPermissionRequestHandler( ( webContents, permission, callback ) => {
		// Reject all permission requests
		callback( false );
	} );

	session.defaultSession.webRequest.onHeadersReceived( ( details, callback ) => {
		const policies = [
			"default-src 'self' public-api.wordpress.com wordpress.com", // Allow resources from these domains
			"script-src-attr 'none'",
			"style-src 'self' 'unsafe-inline' s0.wp.com",
			"script-src 'self' 'unsafe-eval' 'unsafe-inline' s0.wp.com",
			"img-src 'self' *.wordpress.com *.gravatar.com *.wp.com",
			process.env.NODE_ENV === 'development' && "script-src 'self' 'unsafe-eval'",
		];

		callback( {
			responseHeaders: {
				...details.responseHeaders,
				'Content-Security-Policy': [ policies.filter( Boolean ).join( '; ' ) ],
			},
		} );
	} );

	setupIpc();
	mainWindow = createWindow();
	setupCustomProtocolHandler();

	if ( process.platform === 'darwin' && process.env.NODE_ENV === 'development' ) {
		const appMenu = Menu.getApplicationMenu();

		appMenu?.items?.[ 0 ].submenu?.insert(
			4,
			new MenuItem( {
				label: 'Test Hard Crash (dev only)',
				click: () => {
					process.crash();
				},
			} )
		);
		appMenu?.items?.[ 0 ].submenu?.insert(
			5,
			new MenuItem( {
				label: 'Test Render Failure (dev only)',
				click: () => {
					mainWindow?.webContents.send( 'test-render-failure' );
				},
			} )
		);

		Menu.setApplicationMenu( appMenu );
	}
} );

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on( 'window-all-closed', () => {
	if ( process.platform !== 'darwin' ) {
		app.quit();
	}
} );

app.on( 'quit', () => {
	stopAllServersOnQuit();
} );

app.on( 'activate', () => {
	// On OS X it's common to re-create a window in the app when the
	// dock icon is clicked and there are no other windows open.
	if ( BrowserWindow.getAllWindows().length === 0 ) {
		createWindow();
	}
} );
