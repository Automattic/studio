import { app, utilityProcess, UtilityProcess } from 'electron';
import { PHPRunOptions } from '@php-wasm/universal';
import { WPNowOptions } from '../../vendor/wp-now/src/config';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const SITE_SERVER_PROCESS_MODULE_PATH: string;

export type MessageName = 'start-server' | 'stop-server' | 'run-php';

const DEFAULT_RESPONSE_TIMEOUT = 25000;

export default class SiteServerProcess {
	lastMessageId = 0;
	options: WPNowOptions;
	process?: UtilityProcess;
	php?: { documentRoot: string };
	url: string;

	constructor( options: WPNowOptions ) {
		this.options = options;
		this.url = options.absoluteUrl ?? '';
	}

	async start(): Promise< void > {
		return new Promise( ( resolve, reject ) => {
			this.process = utilityProcess
				.fork( SITE_SERVER_PROCESS_MODULE_PATH, [ JSON.stringify( this.options ) ], {
					serviceName: 'studio-site-server',
					env: {
						...process.env,
						STUDIO_SITE_SERVER_PROCESS: 'true',
						STUDIO_APP_NAME: app.name,
						STUDIO_APP_DATA_PATH: app.getPath( 'appData' ),
						STUDIO_APP_LOGS_PATH: app.getPath( 'logs' ),
					},
				} )
				.on( 'spawn', async () => {
					const messageId = this.sendMessage( 'start-server' );
					try {
						const { php } = await this.waitForMessage< Pick< SiteServerProcess, 'php' > >(
							'start-server',
							messageId
						);
						this.php = php;
						resolve();
					} catch ( error ) {
						reject( error );
					}
				} )
				.on( 'exit', ( code ) => {
					if ( code !== 0 ) {
						reject( new Error( `Site server process exited with code: ${ code }` ) );
					}
				} );
		} );
	}

	async stop() {
		const message = 'stop-server';
		const messageId = this.sendMessage( message );
		await this.waitForMessage( message, messageId );
	}

	async runPhp( data: PHPRunOptions ): Promise< string > {
		const message = 'run-php';
		const messageId = this.sendMessage( message, data );
		return await this.waitForMessage( message, messageId );
	}

	sendMessage< T >( message: MessageName, data?: T ) {
		const process = this.process;
		if ( ! process ) {
			throw Error( 'Server process is not running' );
		}

		const messageId = +this.lastMessageId;
		process.postMessage( { message, messageId, data } );
		return messageId;
	}

	async waitForMessage< T = undefined >(
		originalMessage: MessageName,
		originalMessageId: number,
		timeout = DEFAULT_RESPONSE_TIMEOUT
	): Promise< T > {
		const process = this.process;
		if ( ! process ) {
			throw Error( 'Server process is not running' );
		}

		return new Promise( ( resolve, reject ) => {
			const handler = ( {
				message,
				messageId,
				data,
				error,
			}: {
				message: MessageName;
				messageId: number;
				data: T;
				error?: Error;
			} ) => {
				if ( message !== originalMessage || messageId !== originalMessageId ) {
					return;
				}
				if ( typeof error !== 'undefined' ) {
					reject( error );
					return;
				}
				process.removeListener( 'message', handler );
				clearTimeout( timeoutId );
				resolve( data );
			};

			const timeoutId = setTimeout( () => {
				reject( new Error( `Request for message ${ originalMessage } timed out` ) );
				process.removeListener( 'message', handler );
			}, timeout );

			process.addListener( 'message', handler );
		} );
	}
}
