import { app, utilityProcess, UtilityProcess } from 'electron';
import * as Sentry from '@sentry/electron/renderer';
import { executeWPCli } from '../../vendor/wp-now/src/execute-wp-cli';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const WP_CLI_PROCESS_MODULE_PATH: string;

export type MessageName = 'execute';

const DEFAULT_RESPONSE_TIMEOUT = 120000;

export default class WpCliProcess {
	lastMessageId = 0;
	process?: UtilityProcess;

	async execute(
		projectPath: string,
		args: string[]
	): Promise< ReturnType< typeof executeWPCli > > {
		return new Promise( ( resolve, reject ) => {
			const spawnListener = async () => {
				const messageId = this.sendMessage( 'execute', { projectPath, args } );
				try {
					const response = await this.waitForResponse< ReturnType< typeof executeWPCli > >(
						'execute',
						messageId
					);
					// Removing exit listener as we only need it upon starting
					this.process?.off( 'exit', exitListener );
					resolve( response );
				} catch ( error ) {
					reject( error );
				} finally {
					// The process is automatically killed after the execution
					this.#killProcess();
				}
			};
			const exitListener = ( code: number ) => {
				if ( code !== 0 ) {
					reject( new Error( `wp-cli process exited with code ${ code } upon starting` ) );
				}
			};

			this.process = utilityProcess
				.fork( WP_CLI_PROCESS_MODULE_PATH, [], {
					serviceName: 'studio-wp-cli-process',
					env: {
						...process.env,
						STUDIO_IN_CHILD_PROCESS: 'true',
						STUDIO_APP_NAME: app.name,
						STUDIO_APP_DATA_PATH: app.getPath( 'appData' ),
						STUDIO_APP_LOGS_PATH: app.getPath( 'logs' ),
					},
				} )
				.on( 'spawn', spawnListener )
				.on( 'exit', exitListener );
		} );
	}

	async stop() {
		await this.#killProcess();
	}

	sendMessage< T >( message: MessageName, data?: T ) {
		const process = this.process;
		if ( ! process ) {
			throw Error( 'wp-cli process is not running' );
		}

		const messageId = +this.lastMessageId;
		process.postMessage( { message, messageId, data } );
		return messageId;
	}

	async waitForResponse< T = undefined >(
		originalMessage: MessageName,
		originalMessageId: number,
		timeout = DEFAULT_RESPONSE_TIMEOUT
	): Promise< T > {
		const process = this.process;
		if ( ! process ) {
			throw Error( 'wp-cli process is not running' );
		}

		return new Promise( ( resolve, reject ) => {
			const handler = ( {
				message,
				messageId,
				data,
				error,
			}: {
				message: MessageName;
				messageId: number;
				data: T;
				error?: Error;
			} ) => {
				if ( message !== originalMessage || messageId !== originalMessageId ) {
					return;
				}
				process.removeListener( 'message', handler );
				clearTimeout( timeoutId );
				if ( typeof error !== 'undefined' ) {
					reject( error );
					return;
				}
				resolve( data );
			};

			const timeoutId = setTimeout( () => {
				reject( new Error( `Request for message ${ originalMessage } timed out` ) );
				process.removeListener( 'message', handler );
			}, timeout );

			process.addListener( 'message', handler );
		} );
	}

	async #killProcess(): Promise< void > {
		const process = this.process;
		if ( ! process ) {
			throw Error( 'wp-cli process is not running' );
		}

		return new Promise< void >( ( resolve, reject ) => {
			process.once( 'exit', ( code ) => {
				if ( code !== 0 ) {
					reject( new Error( `wp-cli process exited with code ${ code } upon stopping` ) );
					return;
				}
				resolve();
			} );
			process.kill();
		} ).catch( ( error ) => {
			Sentry.captureException( error );
		} );
	}
}
