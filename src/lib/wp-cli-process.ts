import { app, utilityProcess, UtilityProcess } from 'electron';
import * as Sentry from '@sentry/electron/renderer';
import { executeWPCli } from '../../vendor/wp-now/src/execute-wp-cli';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const WP_CLI_PROCESS_MODULE_PATH: string;

export type MessageName = 'execute';
export type WpCliResult = ReturnType< typeof executeWPCli >;
export type MessageCanceled = { error: Error; canceled: boolean };

const DEFAULT_RESPONSE_TIMEOUT = 120000;

export default class WpCliProcess {
	lastMessageId = 0;
	process?: UtilityProcess;
	ongoingMessages: Record< number, { cancelHandler: () => void } > = {};
	projectPath: string;

	constructor( projectPath: string ) {
		this.projectPath = projectPath;
	}

	async init(): Promise< void > {
		return new Promise( ( resolve, reject ) => {
			const spawnListener = async () => {
				// Removing exit listener as we only need it upon starting
				this.process?.off( 'exit', exitListener );
				resolve();
			};
			const exitListener = ( code: number ) => {
				if ( code !== 0 ) {
					reject( new Error( `wp-cli process exited with code ${ code } upon starting` ) );
				}
			};

			this.process = utilityProcess
				.fork( WP_CLI_PROCESS_MODULE_PATH, [], {
					serviceName: 'studio-wp-cli-process',
					env: {
						...process.env,
						STUDIO_IN_CHILD_PROCESS: 'true',
						STUDIO_APP_NAME: app.name,
						STUDIO_APP_DATA_PATH: app.getPath( 'appData' ),
						STUDIO_APP_LOGS_PATH: app.getPath( 'logs' ),
					},
				} )
				.on( 'spawn', spawnListener )
				.on( 'exit', exitListener );
		} );
	}

	async execute( args: string[] ): Promise< WpCliResult > {
		const message = 'execute';
		const messageId = this.sendMessage( message, { projectPath: this.projectPath, args } );
		return await this.waitForResponse( message, messageId );
	}

	async stop() {
		await this.#killProcess();
	}

	sendMessage< T >( message: MessageName, data?: T ) {
		const process = this.process;
		if ( ! process ) {
			throw Error( 'wp-cli process is not running' );
		}

		const messageId = this.lastMessageId++;
		process.postMessage( { message, messageId, data } );
		return messageId;
	}

	async waitForResponse< T = undefined >(
		originalMessage: MessageName,
		originalMessageId: number,
		timeout = DEFAULT_RESPONSE_TIMEOUT
	): Promise< T > {
		const process = this.process;
		if ( ! process ) {
			throw Error( 'wp-cli process is not running' );
		}
		if ( this.ongoingMessages[ originalMessageId ] ) {
			throw Error(
				`The 'waitForResponse' function was already called for message ID ${ originalMessageId } from the message '${ originalMessage }'. 'waitForResponse' may only be called once per message ID.`
			);
		}

		return new Promise( ( resolve, reject ) => {
			const handler = ( {
				message,
				messageId,
				data,
				error,
			}: {
				message: MessageName;
				messageId: number;
				data: T;
				error?: Error;
			} ) => {
				if ( message !== originalMessage || messageId !== originalMessageId ) {
					return;
				}
				process.removeListener( 'message', handler );
				clearTimeout( timeoutId );
				delete this.ongoingMessages[ originalMessageId ];
				if ( typeof error !== 'undefined' ) {
					reject( error );
					return;
				}
				resolve( data );
			};

			const timeoutHandler = () => {
				reject( new Error( `Request for message ${ originalMessage } timed out` ) );
				process.removeListener( 'message', handler );
			};
			const timeoutId = setTimeout( timeoutHandler, timeout );
			const cancelHandler = () => {
				clearTimeout( timeoutId );
				reject( {
					error: new Error( `Request for message ${ originalMessage } was canceled` ),
					canceled: true,
				} as MessageCanceled );
				process.removeListener( 'message', handler );
			};
			this.ongoingMessages[ originalMessageId ] = { cancelHandler };

			process.addListener( 'message', handler );
		} );
	}

	async #killProcess(): Promise< void > {
		const process = this.process;
		if ( ! process ) {
			throw Error( 'wp-cli process is not running' );
		}

		this.#cancelOngoingMessages();

		return new Promise< void >( ( resolve, reject ) => {
			process.once( 'exit', ( code ) => {
				if ( code !== 0 ) {
					reject( new Error( `wp-cli process exited with code ${ code } upon stopping` ) );
					return;
				}
				resolve();
			} );
			process.kill();
		} ).catch( ( error ) => {
			Sentry.captureException( error );
		} );
	}

	#cancelOngoingMessages() {
		Object.values( this.ongoingMessages ).forEach( ( { cancelHandler } ) => {
			cancelHandler();
		} );
	}
}
